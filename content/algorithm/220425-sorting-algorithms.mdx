---
title: "[JS] Sorting Algorithms"
date: "2022-04-25 12:54"
emoji: "🍦"
category: "algorithm"
---
## Bubble Sort(거품 정렬)
거품 정렬은 **인접한 원소끼리 비교하고, 원소가 잘못된 순서라면 자리를 교환**해 정렬하는 알고리즘이다.

비교를 1회전 진행하면 순서가 가장 뒤인 원소가 맨 뒤로 이동하기 때문에 다음 회전부터는 뒤로 이동시킨 원소를 제외시킨다.
회전마다 비교하는 원소가 하나씩 줄어들고, 비교할 원소가 없을 때까지 진행하면 정렬이 완료된다.

<img src="https://camo.githubusercontent.com/34e1e2a85f90e3d7c005ada9e1c7a5f57a7eb9a4d519fb369b276a0dd7f5aec9/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f632f63382f427562626c652d736f72742d6578616d706c652d33303070782e676966" />

### Implementation
```js
function bubbleSort(arr) { // ascending order
    for(let iter = 0; iter < arr.length - 1; iter++) {
        for(let index = 0; index < arr.length - 1 - iter; index++) {
            if(arr[index] > arr[index + 1]) {
                [arr[index], arr[index + 1]] = [arr[index + 1], arr[index]];
            }
        }
    }
    return arr;
}
```

### Complexity

|Name|Best|Average|Worst|Stable|In-place|
|---|---|---|---|---|---|
|Bubble Sort|$O(N^2)$|$O(N^2)$|$O(N^2)$|Yes|Yes|

Best case 성능을 개선하기 위해서는 이번 회전에서 교환이 발생했는지 안했는지 검사한 후,
교환이 한 번도 발생하지 않았다면 바로 정렬을 끝내면 된다. 이렇게 되면 best case는 $O(N)$이 된다.

> **Inplace?** 정렬을 위해 추가적인 메모리 공간이 거의 안드는 정렬을 의미한다.
>
> **Stable?** 정렬했을 때 중복된 값들의 순서가 변하지 않음을 의미한다.

### Pros & Cons
거품 정렬은 구현이 매우 간단하다는 장점 외에는 좋은 점이 하나도 없다.

알고리즘을 최적화하지 않는다면 best, average, worst case가 모두 $O(N^2)$의 시간복잡도를 갖는 비효울적인 알고리즘이다.
또한 원소가 자기 자리를 찾아가기 위해 굉장히 많은 교환 연산이 필요하다.

## Selection Sort(선택 정렬)
선택 정렬은 **해당 순서에 넣을 원소를 찾아 넣어 정렬**하는 알고리즘이다.

맨 처음부터 시작해서 배열의 가장 앞 순서에 와야할 원소를 찾아 맨 앞과 교체하고, 그 다음부터 다시 시작해서 정렬이 완료될 때까지 반복한다.

<img src="https://camo.githubusercontent.com/fe834a61b6e60d9e46d124f8c5b90e73f7b44db1442371932aa069257654493a/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f392f39342f53656c656374696f6e2d536f72742d416e696d6174696f6e2e676966" />

### Implementation
```js
function selectionSort(arr) { // ascending order
    for(let target = 0; target < arr.length - 1; target++) {
        let minIndex = target;
        for(let index = target + 1; index < arr.length; index++) {
            if(arr[minIndex] > arr[index]) minIndex = index;
        }
        [arr[target], arr[minIndex]] = [arr[minIndex], arr[target]];
    }
    return arr;
}
```

### Complexity

|Name|Best|Average|Worst|Stable|In-place|
|---|---|---|---|---|---|
|Selection Sort|$O(N^2)$|$O(N^2)$|$O(N^2)$|No|Yes|

매 반복마다 주어진 배열 전체를 비교하기 때문에 best, average, worst case 모두 $O(N^2)$의 시간복잡도를 가진다.

### Pros & Cons
버블 정렬과 마찬가지로 구현이 매우 단순하다.

선택 정렬도 버블 정렬과 같이 $O(N^2)$의 시간복잡도를 가지지만,
비교 횟수에 비해 실제로 교환 연산은 적기 때문에 버블 정렬보다 대부분 빠르게 동작한다.

하지만 비효율적인건 마찬가지다.

그리고 **unstable**하다는 단점을 가진다.

예를 들어, `[4, 3, 2, 4, 1]`을 정렬한다고 해보자.
첫 번째 반복에서 `1`이 앞으로 옮겨져 `[1, 3, 2, 4, 4]`가 된다. 앞의 `4`가 뒤의 `4`보다 뒤로가면서 중복된 값의 순서가 변경됐다.

## Insertion Sort(삽입 정렬)
삽입 정렬은 모든 요소를 앞에서부터 차례대로 이미 정렬된 부분과 비교해서 자신의 위치를 찾아 삽입하는 알고리즘이다.

두 번째 요소부터 시작해서 그 앞의 원소들과 비교해 삽입할 위치를 지정해 삽입하고, 이것을 반복한다.

<img src="https://camo.githubusercontent.com/ac772dfad98df54c1658e98dcfeb11f76aa7e7f027558554067c9eeef219d852/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f302f30662f496e73657274696f6e2d736f72742d6578616d706c652d33303070782e676966" />

### Implementation
```js
function insertionSort(arr) { // ascending order
    for(let start = 1; start < arr.length; start++) {
        const elem = arr[start];
        let index = start - 1;
        for(index; index >= 0; index++) {
            if(elem < arr[index]) arr[index + 1] = arr[index];
        }
        arr[index + 1] = elem;
    }
    return arr;
}
```

### Complexity
|Name|Best|Average|Worst|Stable|In-place|
|---|---|---|---|---|---|
|Selection Sort|$O(N)$|$O(N^2)$|$O(N^2)$|Yes|Yes|

배열이 이미 정렬되어있는 경우 요소의 이동없이 한 번의 비교만 이루어지기 때문에 $O(N)$의 시간복잡도를 가진다.

### Pros & Cons
구현이 간단하고 선택정렬과 버블정렬에 비해 빠르다는 장점을 가진다.

하지만, 배열의 크기가 커지면 마찬가지로 비효율적이다.

<br/>

참조:  
<https://github.com/trekhleb/javascript-algorithms>