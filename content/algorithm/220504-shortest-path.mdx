---
title: "[JS] Sigle-Source Shortest Paths"
date: "2022-05-04 23:01"
emoji: "🛵"
category: "algorithm"
---

Shortest path(최단 경로) 문제는 주어진 그래프에서 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제다.

그래프에서 최단 경로를 찾는 문제를 해결할 때 가장 중요한 것은 **음수 가중치를 갖는 간선이 있는지** 여부다.
음수 간선이 존재하면 음수 사이클이 생길 수 있는데, 음수 사이클이 생기면 경로의 길이가 `-Infinity`까지 발산할 수 있기 때문이다.
**음수 사이클이 있는 그래프에서는 어떤 최단 경로 알고리즘도 최단 경로를 정확히 찾을 수 없다.**

그래프의 종류와 특성에 따라 많은 최단 경로 알고리즘이 존재하지만,
여기서는 **단일 시작점 최단 경로** 알고리즘 두가지를 볼 것이다.

## Dijkstra algorithm
다익스트라 알고리즘은 **그래프에 음수 간선이 없을 때** 사용할 수 있다. 한 노드에서 다른 노드들까지 최단 거리를 계산할 수 있다.

현실 세계는 음의 간선이 존재하지 않기 때문에 현실 세계에 사용하기 매우 적합한 알고리즘 중 하나다.

다익스트라 알고리즘은 '그리디'한 접근을 사용한다.
시작점 `u`에서 시작해서 점점 확장해 나가면서 다른 노드까지의 최단 경로를 갱신한다.
시작점에서 가까운 순서대로 정점을 방문하는 것이 BFS와 비슷하지만,
현재 확정한 경로와 연결된 모든 노드를 조사하는 것이 아닌 **가장 가중치가 작은 노드를 선택**한다는 점이 다르다.

이때 가장 가중지차 작은 노드를 선택하기 위해 **우선순위 큐**를 사용한다.

### 구현
먼저 각 정점까지의 최단 거리를 저장하는 배열 `dist`를 만들고 시작점은 `0`, 다른 노드들을 `Infinity`로 초기화한다.
시작점부터해서 정점을 방문할 때마다 인접한 정점을 모두 검사한다.
만약 현재까지 가중치에 간선의 가중치를 더한 값이 인접한 정점의 가중치보다 작은 경우, 최단 거리를 갱신해주고 `[노드, 가중치]`쌍을 우선순위 큐에 넣어준다.

이때 우선순위 큐 안에 있는 노드의 가중치 정보와 `dist`에 있는 정보가 불일치 하는 경우가 발생할 수 있다.
이 경우는 우선순위 큐에서 노드가 나왔을 때, 가중치가 `dist`의 가중치보다 크면 더 짧은 경로가 발견됐다는 의미기 때문에 무시해주면 된다.

```js
function dijkstra(n, edges, src) {
    const adjList = Array.from(Array(n), () => []);
    const dist = Array(n).fill(Infinity);
    edges.forEach(([u, v, w]) => adjList[u].push([v, w]));

    const pq = new MinHeap();
    pq.push([src, 0]);
    dist[src] = 0;
    while(pq.heap.length) {
        const [cur, weight] = pq.pop();
        // 더 짧은 경로가 발견됐다면 무시
        if(dist[cur] < weight) continue;
        adjList[cur].forEach(([next, nextWeight]) => {
            if(dist[next] > weight + nextWeight) {
                dist[next] = weight + nextWeight;
                pq.push([next, weight + nextWeight]);
            }
        });
    }

    return dist;
}
```

## Bellman-Ford


참조:  
<https://m.blog.naver.com/ndb796/221234424646>