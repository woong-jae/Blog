---
title: "[JS] 함수(Functions)"
date: "2021-08-22"
emoji: "⚙️"
category: "javascript"
---

> **함수는 자바스크립트 프로그래밍의 핵심이다.** 하나의 프로그램과 하나의 값을 묶은 개념은 다양한 용도로 사용될 수 있다.

## 함수 정의하기
가장 기본적인 함수 정의(definition)는 바인딩의 값을 함수로 주는 방법이다. `function` 키워드로 시작하는 표현식에 **parameters(매개 변수)**와 함수가 호출되면 실행될 구문들이 포함된 **body**가 있다.
이런 방식으로 작성된 함수의 'body'는 항상 중괄호(braces)로 묶여야 한다.
```js
const square = function(x) {
    return x * x;
};
```
함수의 `return`값으로 아무 표현식이 없으면 `undefined`가 반환된다. `return`이 없는 함수의 경우도 `undefined`가 반환된다.
***
## 바인딩과 범위(Scope)
모든 바인딩에는 범위가 있다. **범위(Scope)**는 바인딩을 식별할 수 있는 프로그램의 영역을 말한다.

함수나 블록 밖에서 정의된 바인딩의 경우 프로그램 전체에서 사용될 수 있게 된다. 전역에서 사용할 수 있으니, 이것을 **'global binding'**이라고 한다.

함수의 파라미터나 함수 내부에서 선언한 바인딩은 해당 함수에서만 참조할 수 있게 된다. 이것을 **'local binding'**이라고 한다. 이런 녀석들은 함수가 호출될 때마다 새로운 인스턴스가 생성된다.

`let`이나 `const`키워드로 생성된 바인딩은 선언된 'block'까지가 지역 범위가 된다. 
2015년 이전의 자바스크립트에서는 함수에서만 새 범위를 만들었기 때문에, `var`키워드로 만든 바인딩은 **같은 함수 내부라면 어떤 블럭 안에 있어도 사용**할 수 있게 된다.
```js
let x = 10;
if (true) {
    let y = 20;
    var z = 30;
    console.log(x + y + z); // -> 60
}
// y는 사용될 수 없다.
console.log(x + z); // -> 40
```

### Nested Scope(범위 중첩)
블록과 함수는 다른 블록과 함수 내부에 생성될 수 있다. 따라서 여러 단계의 지역성(locality)이 생성될 수 있다. 
모든 지역 범위에서는 해당 범위에 포함된 모든 지역 지역 범위의 바인딩을 식별할 수 있고, 모든 범위에서는 전역 범위의 바인딩을 식별할 수 있다.
이런 바인딩의 식별별 범위 접근 방식을 'lexical scoping'이라고 한다.

### Functions as 'Values'
함수 값은 다른 값과 사용 방법이 동일하다. 즉, 아무 표현식에서나 사용할 수 있고 **새 바인딩에 함수 값을 저장**하거나 **다른 함수에 인수로 전달**하는 등 작업이 가능하다.
***
## 선언 방법
처음에 보여줬던 방법보다 더 빠르게 생성하는 방법이 있다. 바로 함수 선언(declaration)이다.
```js
function square(x) {
    return x * x;
}
```
함수를 선언하는데는 함수 정의와 중요한 차이점이 있다. 

```js
console.log("미래에서 보내는 메시지:", future());

function future() {
    return "아직도 하늘을 나는 자동차는 없네요ㅎㅎ;";
}
```
바로 함수를 사용하는 코드의 아래쪽에 함수가 정의돼 있어도 동작한다는 것이다! 함수 선언은 일반적인 'top-to-bottom' 흐름에 속하지 않는다.

### 화살표 함수(Arrow Function)
`function` 키워드를 사용하지 않고 이름 그대로 화살표(=>)를 사용한다.
```js
const square = (x) => {
    return x * x;
};
```
문법을 보면 "이것을 입력하면 이 결과가 나온다"라고 읽을 수 있을 것 같다.

매개변수가 하나만 존재하는 경우 주위 괄호를 생략할 수 있다. 매개변수가 없다면 빈 괄호를 사용한다.
본문이 중괄호 안에 있는 블록이 아닌 단일 표현식이면 함수에서 해당하는 표현식을 반환해준다. 위에 나왔던 식을 바꿔 아래와 같이 표현할 수 있다.
```js
const square = x => x * x;
```
***
## 선택적 인수(Optional Arguments)
자바스크립트는 관대하다. 함수에 너무 많은 인수를 보내도, 인수를 좀 덜 보내도 동작한다.
```js
function square(x) { return x * x; }
console.log(square(4, true, "인수 넣을게"));
// -> 16
```
이것의 단점으로는 실수로 함수에 잘못된 개수의 인수를 전달해서 에러가 발생해도 아무도 알려주지 않는다는 것이다.
단점이 있으면 장점도 있는 법. 이 같은 동작을 사용해서 다양한 개수의 인수로 함수를 호출할 수 있다. 아래 예를 보자.
```js
function minus(a, b) {
    if (b === undefined) return -a;
    else return a - b;
}
```
아래 방식으로도 사용할 수 있다.
```js
function power(base, exponent = 2) {
    let result = 1;
    for (let count = 0; count < exponent; count++) {
        result *= base;
    }
    return result;
}
```
두 번째 인수가 제공되지 않으면 `2`가 기본값으로 설정된다.
***
## 클로저(Closure)
우리는 함수를 값으로 취급하고 함수가 호출될 때마다 로컬 바인딩이 다시 만들어진다는 것을 알아보았다.
그럼 만약 로컬 바인딩을 만든 함수 호출이 끝난 상태라면 생성된 로컬 바인딩은 어떻게 될까? 아래 코드를 보자. 
`wrapValue`함수는 `local`이라는 로컬 바인딩을 생성하고, '로컬 바인딩을 반환하는 함수'를 반환한다.
```js
function wrapValue(n) {
    let local = n;
    return () => local;
}

let wrap1 = wrapValue(1);
let wrap2 = wrapValue(2);
console.log(wrap1());
// -> 1
console.log(wrap2());
// -> 2
```
결과를 보듯이 두 바인딩 인스턴스에 계속해서 접근할 수 있다.

이렇게 **외부 범위의 로컬 바인딩 인스턴스를 참조**할 수 있는 기능, 혹은 **함수 주변의 지역 범위에서 바인딩을 참조**하는 함수를 **클로저(closure)**라고 한다.
클로저 덕분에 바인딩의 수명(lifetime)에 대한 걱정을 덜 수 있게 된다. 이런 식의 코드 작성도 가능해진다.
```js
function multiplier(factor) {
    return number => number * factor;
}
let twice = multiplier(2);
console.log(twice(5));
// -> 10
```
함수 값은 '함수 본문에 있는 코드'와 '생성된 환경' 두 가지 모두를 포함하게 된다.

위의 예시를 보면, `multiplier`가 호출되고 `factor`에 `2`를 바인딩한 환경이 생성된다. 반환된 함수 값은 `twice`에 환경과 함께 저장된다.

<br/>

참조: Eloquent JavaScript