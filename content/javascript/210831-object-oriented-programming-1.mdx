---
title: "[JS] 객체지향 프로그래밍(Object-Oriented Programming) - 1" 
date: "2021-08-31"
emoji: "📦"
category: "javascript"
---
## 캡슐화(Encapsulation)
객체 지향의 핵심은 프로그램을 작은 조각으로 나누는 것이다. 각 조각들은 자신의 상태를 자체적으로 관리한다. 

이 조각들을 객체를 사용해서 모델링한다. 객체들은 **interface**를 통해 서로 상호작용한다. 각 인터페이스는 특정 속성과 메서드로 구성된다.
인터페이스의 일부분인 속성을 **'public'**이라고 하고, 외부에서 접근하지 못하는 나머지 속성을 **'private'**이라고 한다. 
Interface를 제공함으로써 안의 세부 구현을 숨길 수 있게 된다.

**이렇게 인터페이스와 구현을 분리하는 방법을 '캡슐화'라고 한다.**

## 메서드
함수가 메서드로 호출되면, 함수 내부에서 사용되는 `this` 키워드는 자동적으로 **호출한 객체를 가리킨다**.
```js
function speak(line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
}
let whiteRabbit = { type: "white", speak };
whiteRabbit.speak("Give me carrot");
// -> The white rabbit says 'Give me carrot'
```
명시적으로 `this` 매개변수를 전달할 수도 있다. 함수의 `call` 메서드는 첫 번째 인수로 `this`의 값을 받고 나머지 인수를 일반 파라미터로 받는다.
```js
speak.call(whiteRabbit, "Brup!");
// -> The white rabbit says 'Burp!'
```
모든 **함수는 자신만의 `this`를 가진다**. 따라서 `function` 키워드로 정의한 함수 안에서 주변 범위의 `this`를 참조할 수 없다.
**`this`의 대상은 런타임에 결정**된다.

근데 **arrow function**은 좀 다르다. 요놈은 **자신만의 `this`를 가지지 않는 대신, 주변 범위의 `this`를 참조할 수 있다**. 아래 예를 보자.
```js
function normalize() {
    console.log(this.coords.map(n => n / this.length));
}
normalize.call({coords: [0, 2, 3]}, length: 5);
// -> [0, 0.4, 0.6]
```
`normalize` 함수 안의 `map`에서 `function` 키워드를 사용히면 코드가 동작하지 않는다.

## 프로토타입(Prototypes)
자바스크립트의 객체는 `[[Prototype]]`이라는 숨은 속성을 갖는다. 이 속성의 값은 `null`이거나 다른 객체에 대한 참조가 되는데,
다른 객체를 참조하는 경우 참조 대상을 *'프로토타입'*이라 부른다.

어떤 객체에서 속성을 읽으려고 하는데 **해당 속성이 없으면 자바스크립트는 자동으로 프로토타입에서 속성을 찾는다**. 이것을 '프로토타입 상속'이라 부른다.

`[[Prototype]]`은 숨김 속성이지만, 개발자가 직접 값을 설정할 수 있다.

`Object.getPrototypeOf`/`Object.setPrototypeOf` 메서드는 프로토타입의 getter와 setter 역할을 한다.

```js
let animal = { eats: true };
let rabbit = { jumps: true };
Object.setPrototypeOf(rabbit, animal);
console.log(rabbit.eats);
// -> true
```

`rabbit`엔 `eats` 속성이 없지만, 자바스크립트는 `[[Prototype]]`이 참조하고 있는 객체인 `animal`에서 `eats`를 얻어낸다.
이렇게 프로토타입에서 상속받은 속성을 '상속 속성(inherited property)'라고 한다.

`rabbit`은 `animal`을, `animal`은 `Object.prototype`을, `Object.prototype`은 `null`을 상속받고 있다.
거의 모든 프로토타입은 조상으로 `Object.prototype`을 가진다.

> `animal`이 `Object.prototype`을 상속받는 이유는 객체 리터럴로 선언했기 때문이다.

객체의 프로토타입을 변경하는 것은 브라우저 및 자바스크립트 엔진에서 매우 느린 작업이다. 
상속 구조를 변경하는 것은 광볌위한 영향을 미치고, 프로토타입이 변경된 객체에 접근할 수 있는 모든 코드들에도 영향을 줄 수 있기 때문이다.

따라서 `Object.setPrototypeOf`보다는 `Object.create`를 사용해 원하는 프로토타입으로 객체를 만드는 것이 바람직하다.

```js
let protoRabbit = {
    speak(line) {
        console.log(`The ${this.type} rabbit says '${line}'`);
    }
}
let whiteRabbit = Object.create(protoRabbit);
whiteRabbit.type = "white";
whiteRabbit.speak("hello");
// -> The white rabbit says 'hello'
```

## 클래스(Classes)
자바스크립트의 프로토타입 체계는 'Class'라는 객체 지향의 개념을 비공식적으로 적용한 것으로 볼 수 있다.

**클래스는 객체 타입이 어떤 속성과 메서드를 가지고 있는지 정의**한다. 클래스로부터 **만들어진 객체를 클래스의 'instance'**라고 한다.
프로토타입은 클래스의 모든 인스턴스에서 동일해야 할 속성을 정의하는데 사용한다.

클래스의 인스턴스를 생성할 때, 만들어진 객체가 적절한 프로토타입에서 파생되고 필요한 모든 속성을 가지고 있도록 해야한다. 이것을 해주는 것이 **'constructor(생성자)'** 함수의 역할이다.

아래 예시는 `protoRabbit`을 프로토타입으로 하는 객체를 생성한다. `Object.create()` 메서드는 지정된 프로토타입 객체 및 속성을 갖는 새 객체를 만든다.

```js
function makeRabbit(type) {
    let rabbit = Object.create(protoRabbit);
    rabbit.type = type;
    return rabbit;
}
```

자바스크립트에서 생성자를 더 쉽게 정의할 수 있는 방법을 제공한다. **함수 호출 부분 앞에 `new` 키워드를 사용하면 그 함수는 생성자로 작용**한다.
`new` 연산자를 사용해 만든 객체는 **생성자 함수의 프로토타입 정보를 사용해 [[Prototype]]을 설정**한다.

생성자 함수 `F`의 프로토타입은 `F.prototype`을 통해 설정할 수 있다. `F.prototype`은 '일반 속성'으로, 앞서 언급한 프로토타입과는 다르다.

```js
function Rabbit(type) {
    this.type = type;
}
Rabbit.prototype.speak = function (line) {
    console.log(`The ${this.type} rabbit says '${line}'`);
}
let weirdRabbit = new Rabbit("weird");
```
일반적으로 생성자 함수의 이름은 대문자로 시작해서 다른 함수들과 구분한다.

위 예시에서 `Rabbit` 생성자의 프로토타입은 무엇일까? `Function.prototype`이다. 생성자는 근본적으로 함수이기 때문이다. 

`weirdRabbit`은 생성자의 프로토타입 정보를 사용해서 생성했기 때문에 프로토타입이 `Rabbit.prototype`이다. 
생성자의 **'prototype' 속성 안에 인스턴스의 프로토타입**이 있다.

생성자의 프로토타입 속성은 기본값으로 `constructor` 속성 하나만 가지는 객체를 가리킨다. `constructor` 속성은 함수 자신을 가리킨다.

### 파생 속성 Override
객체에 속성을 주게되면, 그 속성이 프로토타입에 속성으로 있던 없던 해당 객체에 속성이 추가된다. 만약 프로토타입에 같은 이름의 속성이 이미 존재하면, 이 속성은 객체의 속성에 가려져 더이상 객체에 영향을 미치지 못하게 된다.
```js
Rabbit.prototype.teeth = "작음";
console.log(killerRabbit.teeth);
// -> 작음
killerRabbit.teeth = "길고 날카로움";
console.log(killerRabbit.teeth);
// -> 길고 날카로움
```

<br/>

참조:  
Eloquent JavaScript  
<https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/proto>  
ko.javascript.info