---
title: "HTTP"
date: "2021-08-12"
emoji: "📦"
category: "web"
---
## HTTP가 뭔데?
> **Hypertext Transfer Protocol**

HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있게 해주는 응용 계층 프로토콜이다. 프로토콜은 통신 규약이다. 쉽게 말하면 메시지를 주고 받을 때 지켜야 할 양식과 규칙이다. "이거 이렇게 보낼 거니까 요런 식으로 받으세요~"라고 하는거다.

HTTP는 **클라이언트와 서버 사이에 이루어지는 요청/응답**(request/response) 프로토콜이다. 클라이언트인 웹 브라우저가 HTTP를 통해 서버로부터 웹페이지 정보를 요청하면, 서버는 이 요청에 맞는 응답을 하여 필요한 정보를 전달하게 된다.  

## HTTP/1.1
1996년, HTTP의 첫 상용화 버전인 `HTTP/1.0`이 나온 이후 99년에 나온 버전이다. 이 버전에서 통신은 **Persistent HTTP**로 이루어진다.  
`HTTP/1.0`의 경우 메시지를 교환할 때마다 TCP 연결을 새로 열고 닫는다(Non-Persistent). 이렇게 되면 요청마다 TCP 연결 요청, 파일 요청을 하게 되어 **2RTT가 소요**된다. 내가 보낸 메시지가 서버에 갔다가 다시 돌아오는 시간을 **RTT(Round Trip Time)**이라고 한다.  
이를 해결하기 위해 나온게 `HTTP/1.1`이다. Pipelining 기술을 사용해 여러 객체를 주고 받은 후 TCP 연결을 종료한다. 그러면 첫 번째 요청에서만 TCP 연결 요청을 하기 때문에 평균적으로 1RTT가 소요된다.

`HTTP/1.1`은 `FCFS(First Come First Served)`로 동작한다. 영어 뜻 그대로 선착순으로 처리한다는 소리다. 선착순이 사람 기준에서는 참 공정한 방법인데, 네트워크 세계에서는 아닐 수도 있다.  
예를 들어, 내가 3개의 이미지 `a.png`, `b.png`, `c.png`를 순서대로 받을 예정이다. 근데 이미지 `a.png`가 다른 두 놈보다 크기가 훨씬 크다. 선착순으로 처리하기 때문에 `a.png`를 받기 전까지는 다른 뒤에 있는 애들을 받을 수 없게된다. 
"아니 뭐 좀 기다렸다 받으면 안되나?"라고 할 수도 있겠지만, 첫 번째 놈을 처리하는데 99초가 걸리고 나머지는 1초씩 걸린다면? 1초만에 받을 걸 100초, 101초 걸려서 받을 수도 있다는 소리다. 이 문제점을 **HOL(Head of Line) Blocking** 문제라고 한다.  

## HTTP/2
`HTTP/2`는 어떻게 **HOLB 문제**를 개선했을까? 바로 요청과 응답의 멀티플렉싱의 지원을 통해서이다. 멀티플렉싱은 바이너리 프레이밍을 통해 이루어진다. HTTP 메시지를 바이너리 형태의 **프레임(frame)**으로 나누고 전송하고, 받은 측에서 다시 조립한다. 데이터를 프레임이라는 단위로 나눠서 보낼 수 있기 때문에 한 연결으로 동시에 여러 개의 리소스를 주고 받을 수 있다. 이런 바이트의 양방향 흐름을 **스트림(Stream)**이라고 한다.

![multiplexing](https://developers.google.com/web/fundamentals/performance/http2/images/multiplexing01.svg?hl=ko)

`HTTP/2`에서 개선된 점은 이게 끝이 아니다. 요청 우선순위를 지정할 수도 있고, 헤더를 압축하여 헤더 오버헤드를 줄이고, 클라이언트가 명시적으로 요청을 하지 않아도 필요한 리소스를 미리 푸시하여 응답시간을 줄이는 서버 푸시 기능이 추가되었다. 자세한 내용은 너무 길어서 [여기](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)서 보는게 좋을 것 같다.


## HTTP/3
스트림 개념을 도입하여 HOLB 문제를 완화했지만, HLOB는 TCP를 사용하는 이상 완전히 피해갈 수 없는 문제다. 그래서 선택한 것이 기반 프로토콜인 TCP를 버리고 UDP 기반의 `QUIC(Quick UDP Internet Connection)`이다. QUIC은 TCP가 가지고 있는 여러 문제(handshake, HOLB 등)를 해결하고 레이턴시 한계를 뛰어넘고자 구글이 개발한 UDP 기반 프로토콜이다. `HTTP/3`는 **'HTTP-over-QUIC'**, 즉, QUIC 프로토콜 위에서 돌아가는 HTTP란 의미다. 

### 왜 UDP를 사용했지?

TCP와 UDP를 간단히 비교하면 `겁나 무거운 Visual Studio 같은 IDE`와 `VSC`의 비교쯤으로 설명할 수 있을 것 같다. 내가 원하는 기능만 쓰고 싶은데, TCP는 그게 안되고 통째로 다 써야하는 것이다. 즉, 성능개선에 TCP라는 근본적 한계가 있는 것이다.

### 그래서 뭐가 좋아졌을까?

QUIC은 TCP를 사용하지 않기 때문에 번거로운 handshake 과정을 거치지 않아도 된다. TCP 연결같은 경우 TLS를 사용한 암호화까지 한다면 총 3RTT가 필요하다. 반면 QUIC을 사용하면 첫 연결 설정에 1RTT가 소요된다. 이게 가능한 이유는 첫 핸드쉐이크를 거칠 때 필요한 정보와 데이터를 한 번에 보내기 때문이다.  
`HTTP/2`와 동일하게 멀티플렉싱을 지원한다. 하지만 UDP 기반을 사용하기 때문에 TCP에서 발생하는 HOLB까지 잡을 수 있다는 것이 장점이다.


## 마치며
그래서 지금은 젤 최신 기술인 `HTTP/3`를 대부분의 사이트에서 사용할까? 아니다. 아직도 50%가 넘는 웹사이트는 `HTTP/1.1`을 사용한다고 한다. `HTTP/2`도 40% 정도... 기술의 발전과 적용은 다른 이야기인 것이 체감되는 것 같다.

<br />

참조: 
- [wikipedia](https://ko.wikipedia.org/wiki/HTTP)  
- [MDN HTTP overview](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview)  
- [MDN evloution of HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP)  
- [Google developers](https://developers.google.com/web/fundamentals/performance/http2?hl=ko)  
- [https://www.whatap.io/ko/blog/38/](https://www.whatap.io/ko/blog/38/)  
- [https://evan-moon.github.io/2019/10/08/what-is-http3/](https://evan-moon.github.io/2019/10/08/what-is-http3/)